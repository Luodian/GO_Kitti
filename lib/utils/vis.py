# Written by Roy Tseng
#
# Based on:
# --------------------------------------------------------
# Copyright (c) 2017-present, Facebook, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################


from __future__ import absolute_import , division , print_function , unicode_literals

import os
from collections import defaultdict

import cv2
# Use a non-interactive backend
import matplotlib
import numpy as np
import pycocotools.mask as mask_util
import scipy.misc
import utils.keypoints as keypoint_utils
from utils.colormap import colormap

matplotlib.use ( 'Agg' )
import matplotlib.pyplot as plt

plt.rcParams [ 'pdf.fonttype' ] = 42  # For editing in Adobe Illustrator

_GRAY = (218 , 227 , 218)
_GREEN = (18 , 127 , 15)
_WHITE = (255 , 255 , 255)


def kp_connections ( keypoints ) :
	kp_lines = [
		[ keypoints.index ( 'left_eye' ) , keypoints.index ( 'right_eye' ) ] ,
		[ keypoints.index ( 'left_eye' ) , keypoints.index ( 'nose' ) ] ,
		[ keypoints.index ( 'right_eye' ) , keypoints.index ( 'nose' ) ] ,
		[ keypoints.index ( 'right_eye' ) , keypoints.index ( 'right_ear' ) ] ,
		[ keypoints.index ( 'left_eye' ) , keypoints.index ( 'left_ear' ) ] ,
		[ keypoints.index ( 'right_shoulder' ) , keypoints.index ( 'right_elbow' ) ] ,
		[ keypoints.index ( 'right_elbow' ) , keypoints.index ( 'right_wrist' ) ] ,
		[ keypoints.index ( 'left_shoulder' ) , keypoints.index ( 'left_elbow' ) ] ,
		[ keypoints.index ( 'left_elbow' ) , keypoints.index ( 'left_wrist' ) ] ,
		[ keypoints.index ( 'right_hip' ) , keypoints.index ( 'right_knee' ) ] ,
		[ keypoints.index ( 'right_knee' ) , keypoints.index ( 'right_ankle' ) ] ,
		[ keypoints.index ( 'left_hip' ) , keypoints.index ( 'left_knee' ) ] ,
		[ keypoints.index ( 'left_knee' ) , keypoints.index ( 'left_ankle' ) ] ,
		[ keypoints.index ( 'right_shoulder' ) , keypoints.index ( 'left_shoulder' ) ] ,
		[ keypoints.index ( 'right_hip' ) , keypoints.index ( 'left_hip' ) ] ,
	]
	return kp_lines


def convert_from_cls_format ( cls_boxes , cls_segms , cls_keyps ) :
	"""Convert from the class boxes/segms/keyps format generated by the testing
	code.
	"""
	box_list = [ b for b in cls_boxes if len ( b ) > 0 ]
	if len ( box_list ) > 0 :
		boxes = np.concatenate ( box_list )
	else :
		boxes = None
	if cls_segms is not None :
		segms = [ s for slist in cls_segms for s in slist ]
	else :
		segms = None
	if cls_keyps is not None :
		keyps = [ k for klist in cls_keyps for k in klist ]
	else :
		keyps = None
	classes = [ ]
	for j in range ( len ( cls_boxes ) ) :
		classes += [ j ] * len ( cls_boxes [ j ] )
	return boxes , segms , keyps , classes


def vis_bbox_opencv ( img , bbox , thick = 1 ) :
	"""Visualizes a bounding box."""
	(x0 , y0 , w , h) = bbox
	x1 , y1 = int ( x0 + w ) , int ( y0 + h )
	x0 , y0 = int ( x0 ) , int ( y0 )
	cv2.rectangle ( img , (x0 , y0) , (x1 , y1) , _GREEN , thickness = thick )
	return img


def rgb2gray ( rgb ) :
	return np.dot ( rgb [ ... , :3 ] , [ 0.299 , 0.587 , 0.114 ] )


# 这里是从mapillary移植来的cmap
def apply_color_map ( image_array , labels ) :
	color_array = np.zeros ( (image_array.shape [ 0 ] , image_array.shape [ 1 ] , 3) , dtype = np.uint8 )
	
	for label_id , label in enumerate ( labels ) :
		# set all pixels with the current label to the color of the current label
		color_array [ image_array == label_id ] = label [ "color" ]
	
	return color_array


def get_class_string ( class_index , score , dataset ) :
	class_text = dataset.classes [ class_index ] if dataset is not None else \
		'id{:d}'.format ( class_index )
	return class_text + ' {:0.2f}'.format ( score ).lstrip ( '0' )


def vis_one_image (
		im , im_name , output_dir , boxes , segms = None , keypoints = None , thresh = 0.9 ,
		kp_thresh = 2 , dpi = 200 , box_alpha = 0.8 , dataset = None , show_class = False ,
		ext = 'pdf' , labels = None ) :
	"""Visual debugging of detections."""
	# if not os.path.exists ( output_dir ) :
	# 	os.makedirs ( output_dir )
	
	print ("Processing image: {}".format(im_name))
	
	if isinstance ( boxes , list ) :
		boxes , segms , keypoints , classes = convert_from_cls_format (
			boxes , segms , keypoints )
	
	if boxes is None or boxes.shape [ 0 ] == 0 or max ( boxes [ : , 4 ] ) < thresh :
		return
	
	# 这里的mask是一个三维数组,1,2维分别代表原图的横纵坐标，3维一共有当前预测出的instanecs个数的大小。
	if segms is not None :
		masks = mask_util.decode ( segms )
	
	color_list = colormap ( rgb = True ) / 255
	
	# print ( np.unique ( classes ) )
	dataset_keypoints , _ = keypoint_utils.get_keypoints ( )
	kp_lines = kp_connections ( dataset_keypoints )
	cmap = plt.get_cmap ( 'rainbow' )
	colors = [ cmap ( i ) for i in np.linspace ( 0 , 1 , len ( kp_lines ) + 2 ) ]
	
	fig = plt.figure ( frameon = False )
	fig.set_size_inches ( im.shape [ 1 ] / dpi , im.shape [ 0 ] / dpi )
	ax = plt.Axes ( fig , [ 0. , 0. , 1. , 1. ] )
	ax.axis ( 'off' )
	fig.add_axes ( ax )
	ax.imshow ( im )
	
	# Display in largest to smallest order to reduce occlusion
	areas = (boxes [ : , 2 ] - boxes [ : , 0 ]) * (boxes [ : , 3 ] - boxes [ : , 1 ])
	# 默认从大到小排序，先画大的，小的会在后面把大的覆盖，这样大的和小的都能看到。
	sorted_inds = np.argsort ( -areas )
	instance_cnt = defaultdict ( int )
	
	labels_graph = np.zeros ( (im.shape [ 0 ] , im.shape [ 1 ]) )
	
	for item in enumerate(["instances_text","instances","labels"]):
		if not os.path.exists ( os.path.join(output_dir,item[1]) ) :
			os.makedirs(os.path.join(output_dir,item[1]),0o777)
	
	mask_file = open (
		"{}/instances_text/{}.txt".format ( output_dir, im_name ) , "w" )
	
	# output labels prediction
	for i in sorted_inds :
		bbox = boxes [ i , :4 ]
		score = boxes [ i , -1 ]
		# 如果置信度大于0.5，执行
		if score > 0.5 :
			single_mask = masks [ : , : , i ]
			instances_graph = np.zeros ( (im.shape [ 0 ] , im.shape [ 1 ]) )
			
			label_id = classes [ i ]
			instance_cnt [ dataset.classes [ label_id ] ] += 1
			instance_id = instance_cnt [ dataset.classes [ label_id ] ]
			labels_graph [ single_mask == 1 ] = label_id
			instances_graph [ single_mask == 1 ] = 255
			scipy.misc.imsave (
				'{}/instances/{}_{}.png'.format (
					output_dir, im_name , label_id * 256 + instance_id ) , instances_graph )
			
			# 写入格式为mask_file_point class_name score
			mask_file.write (
				"{}/instances/{}_{}.png {} {}\n".format (
					output_dir, im_name , label_id * 256 + instance_id , classes [ i ] , score ) )

	# # current_graph存的是比较raw的值
	# scipy.misc.imsave ( '/nfs/project/libo_i/mask-rcnn.pytorch/map_evaluation_format/raw/{}.jpg'.format ( im_name ) ,
	#                     labels_graph )
	# print ( np.unique ( labels_graph ) )
	# colored_graph里存的是经过config中的cmap赋值之后的值。
	# colored_graph = apply_color_map ( labels_graph , labels )
	# gray_graph = rgb2gray ( colored_graph )
	scipy.misc.imsave ( '{}/labels/{}.png'.format ( output_dir, im_name
	                                                                                                         ) ,
	                    labels_graph )
	
	mask_file.close ( )
# scipy.misc.imsave( '/nfs/project/libo_i/mask-rcnn.pytorch/map_evaluation_format/instances/{}.png'.format ( im_name
#                                                                                                          ) ,
#                     instances_graph )


# print ( "Done" )
# mask_color_id = 0
# for i in sorted_inds :
# 	bbox = boxes [ i , :4 ]
# 	score = boxes [ i , -1 ]
# 	if score < thresh :
# 		continue
#
# 	print ( dataset.classes [ classes [ i ] ] , score )
# 	# show box (off by default, box_alpha=0.0)
# 	ax.add_patch (
# 		plt.Rectangle ( (bbox [ 0 ] , bbox [ 1 ]) ,
# 		                bbox [ 2 ] - bbox [ 0 ] ,
# 		                bbox [ 3 ] - bbox [ 1 ] ,
# 		                fill = False , edgecolor = 'r' ,
# 		                linewidth = 1.0 , alpha = box_alpha ) )
#
# 	if show_class :
# 		ax.text (
# 			# 以图片的左上角为原点，上移两个位置，画出边框.
# 			bbox [ 0 ] , bbox [ 1 ] - 2 ,
# 			get_class_string ( classes [ i ] , score , dataset ) ,
# 			fontsize = 3 ,
# 			family = 'serif' ,
# 			bbox = dict (
# 				facecolor = 'g' , alpha = 0.4 , pad = 0 , edgecolor = 'none' ) ,
# 			color = 'white' )
#
# 	# show mask
# 	if segms is not None and len ( segms ) > i :
# 		img = np.ones ( im.shape )
# 		color_mask = color_list [ mask_color_id % len ( color_list ) , 0 :3 ]
# 		mask_color_id += 1
#
# 		w_ratio = .4
# 		for c in range ( 3 ) :
# 			color_mask [ c ] = color_mask [ c ] * (1 - w_ratio) + w_ratio
# 		for c in range ( 3 ) :
# 			img [ : , : , c ] = color_mask [ c ]
# 		e = masks [ : , : , i ]
#
# 		_ , contour , hier = cv2.findContours (
# 			e.copy ( ) , cv2.RETR_CCOMP , cv2.CHAIN_APPROX_NONE )
#
# 		# mask_color是一个三元组，代表颜色。
# 		for c in contour :
# 			polygon = Polygon (
# 				c.reshape ( (-1 , 2) ) ,
# 				fill = True , facecolor = color_mask ,
# 				edgecolor = 'w' , linewidth = 1.2 ,
# 				alpha = 0.5 )
# 			ax.add_patch ( polygon )
#
# 	output_name = os.path.basename ( im_name ) + '.' + ext
# 	fig.savefig ( os.path.join ( output_dir , '{}'.format ( output_name ) ) , dpi = dpi )
# 	plt.close ( 'all' )
